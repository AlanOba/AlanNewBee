# Spring 

## 1.@Autowired和@Resource的区别

```java
@Autowired 
-可以写在属性上，此时不需要set方法
-可以写在set方法上
默认ByType注入，可以和@Qualifer注解一同使用，ByName注入
@Resource
默认ByName注入，可以指定name或type分别按照名称和类型进行注入

@Primary 必须和@Component等注解一同使用，也即bean.xml文件中配置了，类上不加@Component的话无法使用  
```

**1.日期和字符串之间的转换，如果不转换，在前端无法显示，前端传递的字符串也无法封装为具体的Date类。 simpledateformat  datetoString  stringtoDate**

![image-20210401100529439](/Users/alan/Library/Application Support/typora-user-images/image-20210401100529439.png)

**2.前端新建产品 添加日期时出错，需要在类上添加以下注解**

![image-20210401100332497](/Users/alan/Library/Application Support/typora-user-images/image-20210401100332497.png)



**3。**

![](/Users/alan/Library/Application Support/typora-user-images/image-20210401100855158.png)

涉及到多表查询 

![image-20210401104905211](/Users/alan/Library/Application Support/typora-user-images/image-20210401104905211.png)

**4.订单的分页查询 pageHelper mybatis 的分页插件. 国人开源**

![image-20210401111031729](/Users/alan/Library/Application Support/typora-user-images/image-20210401111031729.png)

![image-20210401110302188](/Users/alan/Library/Application Support/typora-user-images/image-20210401110302188.png)



![image-20210401110558598](/Users/alan/Library/Application Support/typora-user-images/image-20210401110558598.png)

![image-20210401111505460](/Users/alan/Library/Application Support/typora-user-images/image-20210401111505460.png)



​	

**5.**

![image-20210401112350716](/Users/alan/Library/Application Support/typora-user-images/image-20210401112350716.png)



多对一 多对多的查询



![image-20210401114527295](/Users/alan/Library/Application Support/typora-user-images/image-20210401114527295.png)



**6.权限操作**

用户表 角色表 多对多的关系  需要中间表

角色表 权限表 多对多 中间表

![image-20210401115634292](/Users/alan/Library/Application Support/typora-user-images/image-20210401115634292.png)



**7.认证和授权**

![image-20210401142155845](/Users/alan/Library/Application Support/typora-user-images/image-20210401142155845.png)



ps 低层原理 spring会把所有的filter进行加载

Spring-security.xml配置自己的login和failer页面 并设置这两个页面不需要权限操作

登陆的form表单使用的url为/login 这样就可以被Spring security.xml 捕捉



![image-20210401144124991](/Users/alan/Library/Application Support/typora-user-images/image-20210401144124991.png)



spring security.xml中 静态资源不被拦截

![image-20210401143747092](/Users/alan/Library/Application Support/typora-user-images/image-20210401143747092.png)





将数据库中的userInfo和spring security封装的UserDetails类进行绑定

![image-20210401145932315](/Users/alan/Library/Application Support/typora-user-images/image-20210401145932315.png)



spring security 完成用户的注销

spring security.xml文件中配置了点击注销按钮后跳转的url  即logout  然后在xml文件中配置点击注销后需要跳转的页面 也就是 login.xml

 

**8.用户注册的密码加密操作**



在service里对密码进行加密 ps 每次加密的结果都不太一样

![image-20210401155632951](/Users/alan/Library/Application Support/typora-user-images/image-20210401155632951.png)

![image-20210401155618307](/Users/alan/Library/Application Support/typora-user-images/image-20210401155618307.png)

​	ps 删除操作如果设计到中间表，要先删除中间表再删当前表中的数据



**9.权限控制**

![image-20210401172010953](/Users/alan/Library/Application Support/typora-user-images/image-20210401172010953.png)



分为两部分 方法级别和页面上的权限控制

方法级别：

![image-20210401201428201](/Users/alan/Library/Application Support/typora-user-images/image-20210401201428201.png)

页面端：

![image-20210401204257763](/Users/alan/Library/Application Support/typora-user-images/image-20210401204257763.png)

**10.用AOP做日志管理**

前置通知 获取：![image-20210401204503956](/Users/alan/Library/Application Support/typora-user-images/image-20210401204503956.png)



后置通知 获取：![image-20210401204524967](/Users/alan/Library/Application Support/typora-user-images/image-20210401204524967.png)



然后调用SyslogService 将日志插入到数据库中



获取访问的ip地址： 通过request对象获取

在web.xml配置如下

![image-20210401205708928](/Users/alan/Library/Application Support/typora-user-images/image-20210401205708928.png)



在LogAOP里自动注入

![image-20210401205747989](/Users/alan/Library/Application Support/typora-user-images/image-20210401205747989.png)



获取ip：

![image-20210401205820509](/Users/alan/Library/Application Support/typora-user-images/image-20210401205820509.png)





获取当前的操作用户：还可以通过request.getsession的getattribute来获取

总：![image-20210401210042534](/Users/alan/Library/Application Support/typora-user-images/image-20210401210042534.png)



然后将日志的相关信息封装到SysLog对象中

![image-20210401210308374](/Users/alan/Library/Application Support/typora-user-images/image-20210401210308374.png)

调用service的insert操作：略





## 2.Spring中用到的设计模式

### **1.工厂设计模式**

Spring使用工厂模式可以通过 `BeanFactory` 或 `ApplicationContext` 创建 bean 对象。

**两者对比：**

- `BeanFactory` ：延迟注入(使用到某个 bean 的时候才会注入),相比于`BeanFactory`来说会占用更少的内存，程序启动速度更快。
- `ApplicationContext` ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。`BeanFactory` 仅提供了最基本的依赖注入支持，`ApplicationContext` 扩展了 `BeanFactory` ,除了有`BeanFactory`的功能还有额外更多功能，所以一般开发人员使用`ApplicationContext`会更多。

ApplicationContext的三个实现类：

1. `ClassPathXmlApplication`：把上下文文件当成类路径资源。
2. `FileSystemXmlApplication`：从文件系统中的 XML 文件载入上下文定义信息。
3. `XmlWebApplicationContext`：从Web系统中的XML文件载入上下文定义信息。

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
public class App {
    public static void main(String[] args) {
        ApplicationContext context = new FileSystemXmlApplicationContext("C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml");
        HelloApplicationContext obj = (HelloApplicationContext) context.getBean("helloApplicationContext");
        obj.getMsg();
    }
}
```

### **2.单例设计模式**

在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

**使用单例模式的好处:**

- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

**Spring 中 bean 的默认作用域就是 singleton(单例)的。** 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：

- prototype : 每次请求都会创建一个新的 bean 实例。
- request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
- session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。
- global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话

**Spring 实现单例的方式：**

- xml :<bean>标签内 标识 scope的范围
- 注解：`@Scope(value = "singleton")`

**Spring 通过** **`ConcurrentHashMap`** **实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下**

```java
// 通过 ConcurrentHashMap（线程安全） 实现单例注册表
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);

public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
        Assert.notNull(beanName, "'beanName' must not be null");
        synchronized (this.singletonObjects) {
            // 检查缓存中是否存在实例  
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
                //...省略了很多代码
                try {
                    singletonObject = singletonFactory.getObject();
                }
                //...省略了很多代码
                // 如果实例对象在不存在，我们注册到单例注册表中。
                addSingleton(beanName, singletonObject);
            }
            return (singletonObject != NULL_OBJECT ? singletonObject : null);
        }
    }
    //将对象添加到单例注册表
    protected void addSingleton(String beanName, Object singletonObject) {
            synchronized (this.singletonObjects) {
                this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));

            }
        }
}
```

### **3.代理设计模式**

**代理模式在 AOP 中的应用**

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。

**Spring AOP 就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib** ，这时候Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：

![img](https://pic2.zhimg.com/80/v2-18bdb76242192f9694c61abfda8ffb59_720w.jpg)

当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。

使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。

**Spring AOP 和 AspectJ AOP 有什么区别?**

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，

如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。

### **4.模板方法**

模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。

![img](https://pic4.zhimg.com/80/v2-73d2e7ca02dc825c84cede67a921cd9f_720w.jpg)

```java
public abstract class Template {
    //这是我们的模板方法
    public final void TemplateMethod(){
        PrimitiveOperation1();  
        PrimitiveOperation2();
        PrimitiveOperation3();
    }

    protected void  PrimitiveOperation1(){
        //当前类实现
    }

    //被子类实现的方法
    protected abstract void PrimitiveOperation2();
    protected abstract void PrimitiveOperation3();

}
public class TemplateImpl extends Template {

    @Override
    public void PrimitiveOperation2() {
        //当前类实现
    }

    @Override
    public void PrimitiveOperation3() {
        //当前类实现
    }
}
```

==Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类==，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。



### **5.观察者模式**

观察者模式是一种对象行为型模式。==它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应==。==Spring 事件驱动模型==就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。

**Spring 事件驱动模型中的三种角色**

==**事件角色**==

`ApplicationEvent` (`org.springframework.context`包下)充当事件的角色,这是一个抽象类，它继承了`java.util.EventObject`并实现了 `java.io.Serializable`接口。

Spring 中默认存在以下事件，他们都是对 `ApplicationContextEvent` 的实现(继承自`ApplicationContextEvent`)：

- `ContextStartedEvent`：`ApplicationContext` 启动后触发的事件;
- `ContextStoppedEvent`：`ApplicationContext` 停止后触发的事件;
- `ContextRefreshedEvent`：`ApplicationContext` 初始化或刷新完成后触发的事件;
- `ContextClosedEvent`：`ApplicationContext` 关闭后触发的事件。

![img](https://pic2.zhimg.com/80/v2-bdacb5ef36c75d003cbd707899055cc1_720w.jpg)

==**事件监听者角色**==

`ApplicationListener` 充当了事件监听者角色，它是一个接口，里面只定义了一个 `onApplicationEvent（）`方法来处理`ApplicationEvent`。`ApplicationListener`接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 `ApplicationEvent`就可以了。所以，在 Spring中我们只要实现 `ApplicationListener` 接口实现 `onApplicationEvent()` 方法即可完成监听事件

```java
package org.springframework.context;
import java.util.EventListener;
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {
    void onApplicationEvent(E var1);
}
```

==**事件发布者角色**==

`ApplicationEventPublisher` 充当了事件的发布者，它也是一个接口。

```java
@FunctionalInterface
public interface ApplicationEventPublisher {
    default void publishEvent(ApplicationEvent event) {
        this.publishEvent((Object)event);
    }

    void publishEvent(Object var1);
}
```

`ApplicationEventPublisher` 接口的`publishEvent（）`这个方法在`AbstractApplicationContext`类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过`ApplicationEventMulticaster`来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。

**Spring 的事件流程总结**

1. 定义一个事件: 实现一个继承自 `ApplicationEvent`，并且写相应的构造函数；
2. 定义一个事件监听者：实现 `ApplicationListener` 接口，重写 `onApplicationEvent()` 方法；
3. 使用事件发布者发布消息: 可以通过 `ApplicationEventPublisher` 的 `publishEvent()` 方法发布消息。

==Example:==

```java
// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数
public class DemoEvent extends ApplicationEvent{
    private static final long serialVersionUID = 1L;

    private String message;

    public DemoEvent(Object source,String message){
        super(source);
        this.message = message;
    }

    public String getMessage() {
         return message;
          }


// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；
@Component
public class DemoListener implements ApplicationListener<DemoEvent>{

    //使用onApplicationEvent接收消息
    @Override
    public void onApplicationEvent(DemoEvent event) {
        String msg = event.getMessage();
        System.out.println("接收到的信息是："+msg);
    }

}
// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。
@Component
public class DemoPublisher {

    @Autowired
    ApplicationContext applicationContext;

    public void publish(String message){
        //发布事件
        applicationContext.publishEvent(new DemoEvent(this, message));
    }
}
```

当调用 `DemoPublisher` 的 `publish()` 方法的时候，比如 `demoPublisher.publish("你好")`，控制台就会打印出:`接收到的信息是：你好` 。



### **6.适配器模式**

适配器模式(Adapter Pattern) ==将一个接口转换成客户希望的另一个接口==，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。

**spring AOP中的适配器模式**

我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是`AdvisorAdapter` 。Advice 常用的类型有：`BeforeAdvice`（目标方法调用前,前置通知）、`AfterAdvice`（目标方法调用后,后置通知）、`AfterReturningAdvice`(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截  器:`MethodBeforeAdviceInterceptor`、`AfterReturningAdviceAdapter`、`AfterReturningAdviceInterceptor`。Spring预定义的通知要通过对应的适配器，适配成 `MethodInterceptor`接口(方法拦截器)类型的对象（如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`）。

**spring MVC中的适配器模式**

在Spring MVC中，`DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由`HandlerAdapter` 适配器处理。`HandlerAdapter` 作为期望接口，具体的适配器实现类用于对目标类进行适配，`Controller` 作为需要适配的类。

**为什么要在 Spring MVC 中使用适配器模式？** Spring MVC 中的 `Controller` 种类众多，不同类型的 `Controller` 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，`DispatcherServlet` 直接获取对应类型的 `Controller`，需要的自行来判断，像下面这段代码一样：

```java
if(mappedHandler.getHandler() instanceof MultiActionController){  
   ((MultiActionController)mappedHandler.getHandler()).xxx  
}else if(mappedHandler.getHandler() instanceof XXX){  
    ...  
}else if(...){  
   ...  
}  
```

假如我们再增加一个 `Controller`类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。

### **7.装饰者模式**

**装饰者模式可以动态地给对象添加一些额外的属性或行为**。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 `InputStream`家族，`InputStream` 类下有 `FileInputStream` (读取文件)、`BufferedInputStream` (增加缓存,使读取文件速度大大提升)等子类都在不修改`InputStream` 代码的情况下扩展了它的功能。

![img](https://pic2.zhimg.com/80/v2-24de23ef6da7f2becad1458fe1e5e641_720w.jpg)

Spring 中配置 DataSource 的时候，==DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。==Spring 中用到的包装器模式在类名上含有 `Wrapper`或者 `Decorator`。这些类基本上都是动态地给一个对象添加一些额外的职责。

## **总结**

Spring 框架中用到了哪些设计模式？

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。



## [3.静态代理VS动态代理](https://blog.csdn.net/hejingyuan6/article/details/36203505)

# **MyBatis**



# 计算机网络

## 1.TCP三次握手和四次挥手

![img](https://upload-images.jianshu.io/upload_images/16556013-e78f6fc40e06897b?imageMogr2/auto-orient/strip|imageView2/2/w/546)

## 2.time-wait的作用

time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK=1的信号结束后，主动关闭连接方所处的状态。==（即发送端最后一次挥手后等待2msl）==

然后time-wait的的持续时间为2MSL. MSL是Maximum Segment Lifetime,译为==“====报文最大生存时间”==，可为30s，1min或2min。2msl就是2倍的这个时间。工程上为2min，2msl就是4min。但一般根据实际的网络情况进行确定。

原因1：为了==保证客户端发送的最后一个ack报文段能够到达服务器==。因为这==最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文==。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。)，==那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态**(高并发短连接时)**，那么服务器的压力可想而知。==

原因2：在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样==下一次新的连接中就肯定不会出现旧连接的报文段了==。也就是防止我们上一篇文章 [为什么tcp是三次握手而不是两次握手？](https://zhuanlan.zhihu.com/p/51448333) 中说的：已经失效的连接请求报文段出现在本次连接中。如果没有的话就可能这样：这次连接一挥手完马上就结束了，没有timewait。这次连接中有个迷失在网络中的syn包，然后下次连接又马上开始，下个连接发送syn包，迷失的syn包忽然又到达了对面，所以对面可能同时收到或者不同时间收到请求连接的syn包，然后就出现问题了。

## 3.为什么TCP是三次握手？而不是两次或四次？

**初始**

|        | 服务端发送 | 服务端接收 | 客户端发送 | 客户端接收 |
| ------ | ---------- | ---------- | ---------- | ---------- |
| 服务端 | ○          | ○          | ○          | ○          |
| 客户端 | ○          | ○          | ○          | ○          |

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。 服务端接收到报文后，可以确认客户端的发送功能，服务端的接收功能，都是正常的。

|        | 服务端发送 | 服务端接收 | 客户端发送 | 客户端接收 |
| ------ | ---------- | ---------- | ---------- | ---------- |
| 服务端 | ○          | √          | √          | ○          |
| 客户端 | ○          | ○          | ○          | ○          |

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。 客户端接收到第二次握手报文后，可以确认服务端的发送功能，客户端的接收功能是正常的。不过，此时服务端并不知道自己的发送功能，客户端的接收功能是否正常。

|        | 服务端发送 | 服务端接收 | 客户端发送 | 客户端接收 |
| ------ | ---------- | ---------- | ---------- | ---------- |
| 服务端 | ○          | √          | √          | ○          |
| 客户端 | √          | √          | √          | √          |

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1 此时，服务端就可以确认自己的发送功能，客户端的接收功能是正常的。

|        | 服务端发送 | 服务端接收 | 客户端发送 | 客户端接收 |
| ------ | ---------- | ---------- | ---------- | ---------- |
| 服务端 | √          | √          | √          | √          |
| 客户端 | √          | √          | √          | √          |

## 4.如果已经建立了连接，但是客户端突然出现故障了怎么办？



TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## 5.TCP与UDP的区别

1. 对比

|              | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | :------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

2. 总结

- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP



## 6.DNS的解析过程

一、主机向本地域名服务器的查询一般都是采用==递归查询==。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

二、本地域名服务器向根域名服务器的查询的==迭代查询==。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的==顶级域名服务器==的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

下图给出了这两种查询的差别：



![img](https:////upload-images.jianshu.io/upload_images/5679451-9a41405bb9a6d76b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

下面举一个例子演示整个查询过程：

假定域名为m.xyz.com的主机想知道另一个主机y.abc.com的IP地址。例如，主机m.xyz.com打算发送邮件给y.abc.com。这时就必须知道主机y.abc.com的IP地址。下面是上图a的几个查询步骤：

1、主机m.abc.com先向本地服务器dns.xyz.com进行递归查询。

2、本地服务器采用迭代查询。它先向一个根域名服务器查询。

3、根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。

4、本地域名服务器向顶级域名服务器dns.com进行查询。

5、顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。

6、本地域名服务器向权限域名服务器dns.abc.com进行查询。

7、权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。

8、本地域名服务器最后把查询结果告诉m.xyz.com。

整个查询过程共用到了8个UDP报文。

为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。

例如，在上面的查询过程中，如果在m.xyz.com的主机上不久前已经有用户查询过y.abc.com的IP地址，那么本地域名服务器就不必向根域名服务器重新查询y.abc.com的IP地址，而是直接把告诉缓存中存放的上次查询结果(即y.abc.com的IP地址)告诉用户。

由于名字到地址的绑定并不经常改变，为保持告诉缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项(例如每个项目两天)。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。

不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。

## 7.计算机网络各层涉及到的主要协议

**应用层: (典型设备:应用程序，如FTP，SMTP ，HTTP)** 


DHCP(Dynamic Host Configuration Protocol)动态主机分配协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。实 现即插即用连网。 

FTP  （File Transfer Protocol ）文件传输协议<端口号21>减少或消除不同操作系统下处理文件的不兼容性。 

HTTP   （Hypertext Transfer Protocol ）超文本传输协议 <端口号 80>， 面向事务的应用层协议。 

SMTP （Simple Mail Transfer Protocol ）简单邮件传输协议 <端口号25> 用于发送邮件。 
SNMP (Simple Network Management Protocol),简单网络管理协议 

SSH  （Secure Shell ）安全外壳协议 

TELNET   远程登录协议 <端口号23> 


**传输层:  (典型设备:  进程和端口)    数据单元：数据段 （Segment）** 

 TCP  （Transmission Control Protocol ）传输控制协议提供可靠的面向连接的服务，传输数据前须先建立连接，结束后释放。可靠的全双工信道。可靠、有序、无丢失、不重复。 

 UDP (User Datagram Protocol ）用户数据报协议发送数据前无需建立连接，不使用拥塞控制，不保证可靠交付，最大努力交付。 

 DCCP   （Datagram Congestion Control Protocol ）数据报拥塞控制协议 

 SCTP  （STREAM CONTROL TRANSMISSION PROTOCOL ）流控制传 输协议 

RTP(Real-time Transport Protocol ）实时传送协议 

 RSVP  （Resource ReSer Vation Protocol ）资源预留协议 

 PPTP ( Point to Point Tunneling Protocol ）点对点隧道协议 

**网络层: (典型设备:路由器，防火墙、多层交换机) 数据单元：数据包（Packet ）** 

 IP (IPv4 · IPv6) (Internet Protocol) 网络之间互连的协议 

ARP (Address Resolution Protocol) 即地址解析协议，实现通过IP 地址得 知其物理地址。 

RARP (Reverse Address Resolution Protocol)反向地址转换协议允许局域 网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP地址。 

 ICMP (Internet Control Message Protocol ）Internet 控制报文协议。它是TCP/IP 协议族的一个子协议，用于在IP 主机、路由器之间传递控制消息。 

 RIP (Router information protocol) 路由信息协议是一种在网关与主机之间交换路由选择信息的标准。 

OSPF (Open Shortest Path Firs)开放式最短路径优先,分布式链路状态协议。 

 BGP（Border Gateway Protocol ）边界网关协议，用来连接Internet 上独立系统的路由选择协议.采用路径向量路由选择协议。 


**数据链路层: (典型设备:  网卡，网桥，交换机)       数据单元：帧 （Frame）** 

ARQ（Automatic Repeat-reQuest ）自动重传请求协议，错误纠正协议之一，包括停止等待ARQ 协议和连续ARQ 协议，错误侦测、正面确认、逾时重传与负面确认继以重传等机制。 

 停止等待协议： 
 CSMA/CD(Carrrier Sense Multiple Access with Collision Detection)载波监听多点接入/碰撞检测协议。总线型网络，协议的实质是载波监听和碰撞检测。载波监听即发数据前先检测总线上是否有其他计算机在发送数据，如暂时不发数据，避免碰撞。碰撞检测为计算机边发送数据边检测信道上的信号电压大小。 

PPP(Point-to-Ponit Protocol)点对点协议面向字节，由三部分组成：一个将IP 数据报封装到串行链路的方法；一个用于建立、配置和测试数据链路连接的链路控制协议

LCP(Link Control Protocol) ：一套网络控制协议NCP 。 

HDLC  （High-Level Data Link Control ）高级数据链路控制同步网上传输数据、面向比特的数据链路层协议。 

 ATM  （Asynchronous Transfer Mode ）异步传递方式，建立在电路交换和分组交换的基础上的一种面向连接的快速分组交换技术。 “异步”是指将ATM 信元“异步插入”到同步的 SDH 比特流中。如同步插入则用户在每帧中所占的时隙相对位置固定不变。“同步”是指网络中各链路上的比特流都是受同一非常精确的主时钟的控制。Wi-Fi 、WiMAX 、DTM 、令牌环、以太网、FDDI 、帧中继、 GPRS 、 EVDO 、HSPA 、L2TP 、ISDN 


**物理层:(典型设备：中继器，集线器、网线、HUB)              数据单元：比特 （Bit）** 

以太网物理层、调制解调器、PLC 、SONET/SDH 、G.709 、光导纤维、 同轴电缆、双绞线 

# 操作系统

# 数据结构

## 1.各种排序算法的时间复杂度

| 排序法 | 平均时间 | 最差情形   | 稳定度 | 额外空间 | 备注                          |
| ------ | -------- | ---------- | ------ | -------- | ----------------------------- |
| 冒泡   | O(n2)    | O(n2)      | 稳定   | O(1)     | n小时较好                     |
| 交换   | O(n2)    | O(n2)      | 不稳定 | O(1)     | n小时较好                     |
| 选择   | O(n2)    | O(n2)      | 不稳定 | O(1)     | n小时较好                     |
| 插入   | O(n2)    | O(n2)      | 稳定   | O(1)     | 大部分已排序时较好            |
| 基数   | O(logRB) | O(logRB)   | 稳定   | O(n)     | B是真数(0-9)，R是基数(个十百) |
| Shell  | O(nlogn) | O(ns)1<s<2 | 不稳定 | O(1)     | s是所选分组                   |
| 快速   | O(nlogn) | O(n2)      | 不稳定 | O(nlogn) | n大时较好                     |
| 归并   | O(nlogn) | O(nlogn)   | 稳定   | O(1)     | n大时较好                     |
| 堆     | O(nlogn) | O(nlogn)   | 不稳定 | O(1)     | n大时较好                     |



# java基础

## 1.Int 和Integer的比较

```JAVA
Integer i = 100;
Integer j = 100;
System.out.print(i == j); //true

Integer i = 128;
Integer j = 128;
System.out.print(i == j); //false
```

java在编译Integer i = 100 ;时，会翻译成为==Integer i = Integer.valueOf(100==)。而java API中对Integer类型的valueOf的定义如下，对于==-128到127之间的数==，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。

## 2.接口和抽象类的区别

1.接口的方法默认是 public,所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现),而抽象类可以有非抽象的方法。
2.接口中除了 static、 final变量,不能有其他变量,而抽象类中则不ー定。
3.一个类可以实现多个接口,但只能实现一个抽象类。接口自己本身可以通过 extends关键字扩展多个接口。
4.接口方法默认修饰符是 public,抽象方法可以有 public、 protected和 default这些修饰符(抽象方法就是为了被重写所以不能使用private关键字修饰!
5.从设计层面来说,抽象是对类的抽象,是一种==模板设计==,而接口是对行为的抽象,是一种==行为的规范。==

**总结一下jdk1.7~jdk1.9Java中接口概念的变化:**
1.在jdk7或更早版本中,接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。
2.jdk8的时候接口可以有默认方法和静态方法功能。
3.Jdk9在接口中引入了私有方法和私有静态方法。

## 3.深拷贝与浅拷贝

[Java 浅拷贝和深拷贝的理解和实现方式](https://www.cnblogs.com/shakinghead/p/7651502.html)



## 4.ASCII和Unicode编码的区别

**归纳：**

| 编码    | 大小                                                     | 支持语言 |
| :------ | :------------------------------------------------------- | :------- |
| ASCII   | 1个字节                                                  | 英文     |
| Unicode | 2个字节（生僻字4个）                                     | 所有语言 |
| UTF-8   | 1-6个字节，英文字母1个字节，汉字3个字节，生僻字4-6个字节 | 所有语言 |

**具体解释**：

最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。

但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。

你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。

因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。

Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。

新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。

UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

## 5.UTF-8 UTF-16 UTF-32的区别

UTF8、UTF16、UTF32都是unicode字符集的字符编码。
UTF意思是unicode转换格式（Unicode transform format），出现UTF8、UTF16、UTF32是出于要在内存中存储字符的目的而对unicode字符编号进行编码。
UTF8、UTF16、UTF32区别：（8、16、32可看做每种字符编码存储所需的最少的比特位数）
**UTF8**：存在单字节编码，兼容ASCII；当编码为一个字节，则设最高比特位为0；当编码超过一个字节，则需要几个字节，就在第一个字节从最高位开始令连续的几个比特位为1，之后的字节最高位为10。
**UTF16**：使用2或4个字节进行存储。对于Unicode编号范围在0~FFFF之间的字符，统一用两个字节存储，无需字符转换，直接存储Unicode编号。对于Unicode字符编号在10000-10FFFF之间的字符，UTF16用四个字节存储，简单说就是：将Unicode字符编号(3字节)分为两部分，高位部分（Unicode字符编号中占1.5个字节）用一个值介于 D800-DBFF （110110yy yyyyyyyy，y为0/1）之间的双字节存储，低位部分用一个值介于 DC00-DFFF （110111xx xxxxxxxx，x为0/1）的双字节存储。而介于D800-DFFF之间的编码在Unicode中是预留的，不安排字符，如果Unicode中有字符的编号是这之间的值，会引发冲突和歧义，很有可能一个不常见字符（存储为四个字节）最后被读成两个常见字符（存储为两个字节）。

**UTF32**：用固定长度的字节存储字符编码，不管Unicode字符编号需要几个字节，全部都用4个字节存储，直接存储Unicode编号。无需经过字符编号向字符编码的转换步骤，提高效率，用空间换时间。

## 6.java多态的好处

 1.可替换性:多态对已存在的代码具有可替换性。

 2.可扩充性:多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际 上新加子类更容易获得多态功能。　　

 3.接口性:多态是[超类](http://www.so.com/s?q=超类&ie=utf-8&src=wenda_link)通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。

 4.灵活性:它在应用中体现了灵活多样的操作，提高了使用效率。　　

 5.简化性:多态简化了对[应用软件](http://www.so.com/s?q=应用软件&ie=utf-8&src=wenda_link)的代码编写和修改过程。

## 7.装箱和拆箱

[深入剖析Java中的装箱和拆箱](https://www.cnblogs.com/dolphin0520/p/3780005.html)

从反编译得到的字节码内容可以看出，在==装箱的==时候自动调用的是==Integer的valueOf(int)==方法。而在==拆箱==的时候自动调用的是==Integer的intValue方法。==



# java集合



# java多线程



# java虚拟机

## 1.ThreadLocal 的内存泄漏问题

[ThreadLocal 内存泄漏问题深入分析](https://segmentfault.com/a/1190000022704085)

## 2.进程、协程、线程

[进程、线程和协程之间的区别和联系](https://blog.csdn.net/daaikuaichuan/article/details/82951084)

# 数据库

## 1.MyISAM和InnoDB区别和应用场景

### 概述

**MyISAM**：它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果==执行大量的====select，insert==MyISAM比较适合。

**InnoDB**：支持事务安全的引擎，==支持外键、行锁、事务是他的最大特点==。如果有==大量的update和insert==，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。

![95nujil3gz.png](/Users/alan/Downloads/95nujil3gz.png.jpeg)

### MyISAM与InnoDB的主要区别:

**存储结构**

MyISAM：每个MyISAM在磁盘上存储成三个文件。1）.frm 用于存储表的定义。2）.MYD 用于存放数据。 3）.MYI 用于存放表索引

InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

**存储空间**

MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。

InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

**事务支持**

MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。
InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

**表主键**

MyISAM：==允许没有任何索引和主键的表存在，==索引都是保存行的地址。
InnoDB：==如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)==，数据是主索引的一部分，附加索引保存的是主索引的值。

### 应用场景

1. **MyISAM**管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。

2. **InnoDB**用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

   在大数据量，高并发量的互联网业务场景下，请使用InnoDB: ==行锁，对提高并发帮助很大，事务，对数据一致性帮助很大==这两个点，是InnoDB最吸引人的地方。

[深入理解MySQL索引底层实现原理丨技术干货](https://zhuanlan.zhihu.com/p/77383599)

[mysql索引底层原理](https://zhuanlan.zhihu.com/p/54665280)

## 2.MySQL 中 MyISAM 中的查询为什么比 InnoDB 快？

![xcph2aq8jf.png](/Users/alan/Downloads/xcph2aq8jf.png.jpeg)

**那么为什么大家喜欢说 MyisAM 查询快呢？**那是因为，==InnoDB 的表==是根据主键进行展开的 B+tree 的==聚集索引==。==MyIsam== 则非==聚集型索引==，myisam 存储会有两个文件，一个是索引文件，另外一个是数据文件，其中索引文件中的索引指向数据文件中的表数据。

聚集型索引并不是一种单独的索引类型，而是一种存储方式，InnoDB 聚集型索引实际上是在同一结构中保存了 B+tree 索引和数据行。当有聚簇索引时，它的索引实际放在叶子页中。

结合图，可以看出：**INNODB 在做 SELECT 的时候，要维护的东西比 MYISAM 引擎多很多。**

![388dii3px7.png](/Users/alan/Downloads/388dii3px7.png.jpeg)

InnoDB：通过为每一行记录添加两个额外的隐藏的值来实现 ==MVCC==，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。但是 InnoDB 并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是 REPEATABLEREAD 时这种策略是如何应用到特定的操作的：

SELECT InnoDB 必须每行数据来保证它符合两个条件：

![0s5v7dj9rj.png](/Users/alan/Downloads/0s5v7dj9rj.png.jpeg)





## 3.索引失效的情况

[一张图搞懂MySQL的索引失效](https://segmentfault.com/a/1190000021464570)

[Mysql索引（一篇就够le）](https://www.cnblogs.com/zsql/p/13808417.html)

## 4.sql注入的原理及防范

**原理**

​    sql注入的原理是==将sql代码伪装到输入参数中，传递到服务器解析并执行==的一种攻击手法。也就是说，在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。

**示例：**

​    比如我们使用的登录接口：在登录界面包括用户名和密码输入框，以及提交按钮，输入用户名和密码，提交。

​    登录时调用接口/user/login/ 加上参数username、password，首先连接数据库，然后后台对请求参数中携带的用户名、密码进行参数校验，即sql的查询过程。假设正确的用户名和密码为ls和123456，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句。

```mysql
SELECT * FROM user WHERE username = 'ls' AND password = '123456'
```

​    sql中会将#及--以后的字符串当做注释处理，如果我们使用“' or 1=1 #” 作为用户名参数，那么服务端构建的sql语句就如下：

```mysql
select * from users where username='' or 1=1#' and password='123456'
```

  1=1属于常等型条件，因此这个sql便成为了如下，查询出所有的登陆用户。

```mysql
select * from users
```

​    其实上面的sql注入只是在参数层面做了些手脚，如果是引入了一些功能性的sql那就更危险了，比如上面的登陆接口，如果用户名使用这个“' or 1=1;delete * from users; #”，那么在";"之后相当于是另外一条新的sql，这个sql是删除全表，是非常危险的操作，因此sql注入这种还是需要特别注意的。

**防范**---==-sql预编译==

在知道了sql注入的原理之后，我们同样也了解到mysql有预编译的功能，指的是在服务器启动时，mysql client把==sql语句的模板（变量采用占位符进行占位）==发送给mysql服务器，mysql服务器对sql语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，==在最终绑定参数时把相应的参数传送给mysql服务器==，直接进行执行，节省了sql查询时间，以及mysql服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。

```MYSQL
#jdbc中
String sql = "select id, no from user where id=?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setInt(1, id);
ps.executeQuery();
```

**MyBatis中的防止**

\#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。 如: where username=#{username}，如果传入的值是111,那么解析成sql时的值为where username="111", 如果传入的值是id，则解析成的sql为where username="id". 

$将传入的数据直接显示在sql中

```MYSQL
<select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap">
select id, username, password, role
from user
where username = #{username,jdbcType=VARCHAR}
and password = #{password,jdbcType=VARCHAR}
</select>#可以防止sql注入

<select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap">
select id, username, password, role
from user
where username = ${username,jdbcType=VARCHAR}
and password = ${password,jdbcType=VARCHAR}
</select>#不可以防止sql注入
```

**#**{}是经过**预编译的**，是**安全的**；**\*$\***{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。



MySQL框架下SQL注入的三种攻击方式：其一

**in 之后的多个参数**

in之后多个id查询时使用# 同样会报错，

```mysql
Select * from news where id in (#{ids})   
```

正确用法为使用foreach，而不是将#替换为$

```mysql
id in
<foreach collection="ids" item="item" open="("separatosr="," close=")">
#{ids} 
</foreach>   
```

[Mybatis 框架下 SQL 注入攻击的 3 种方式，真是防不胜防！](https://www.cnblogs.com/javastack/p/13277739.html)



## 5.MySQL实现分页查询

### limit 基本实现方式

一般情况下，客户端通过传递 pageNo（页码）、pageSize（每页条数）两个参数去分页查询数据库中的数据，在数据量较小（元组百/千级）时使用 MySQL自带的 `limit` 来解决这个问题：

> 收到客户端{pageNo:1,pagesize:10}
> select * from table limit (pageNo-1)*pageSize, pageSize;

> 收到客户端{pageNo:5,pageSize:30}
> select * from table limit (pageNo-1)*pageSize,pageSize;

### 建立主键或者唯一索引

在数据量较小的时候简单的使用 `limit` 进行数据分页在性能上面不会有明显的缓慢，但是数据量达到了 **万级到百万级** sql语句的性能将会影响数据的返回。这时需要利用主键或者唯一索引进行数据分页；

> 假设主键或者唯一索引为 good_id
> 收到客户端{pageNo:5,pagesize:10}
> select * from table where good_id > (pageNo-1)*pageSize limit pageSize;
> --返回good_id为40到50之间的数据

### 基于数据再排序

当需要返回的信息为顺序或者倒序时，对上面的语句基于数据再排序。order by ASC/DESC 顺序或倒序 默认为顺序

> select * from table where good_id > (pageNo-1)*pageSize order by good_id limit pageSize;
> --返回good_id为40到50之间的数据,数据依据good_id顺序排列



## 6.B树与B+树的比较

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。



## 7.MySQL唯一索引的作用和使用场景

**普通索引**

这是最基本的索引类型，而且它==没有唯一性之类==的限制。

**唯一性索引**

这种索引和前面的“普通索引”基本相同，但有一个区别：==索引列的所有值都只能出现一次，即必须唯一。==

这两种索引的运行原理

**查询过程**

对于==普通索引==来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。

对于==唯一索引==来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，==就会停止继续检索。==

所以在这里你感觉用唯一性索引会快一些，毕竟少了一个步骤。但是这个不同带来的性能差距微乎其微。

你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。

因为引擎是按页读写的，所以说，当找到符合条件的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 

当然也会有特殊情况，就是符合条件的记录正好处于数据页的最后一个，那往下查找的操作就会拿下一个数据页放进内存，这个时候就会慢了，但是一个整型字段，一个数据页可以放进千的key，所以这个概率很低。

**索引具体的处理流程**

清楚了change buffer然后模拟一个场景来看一下两种索引具体的处理流程是怎样的。

如果要在这张表中插入一个 id=5的新纪录，InnoDB 的处理流程是怎样的。

**第一种情况：目标数据页在内存中。**

唯一索引：找到 4 和 6 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
普通索引：找到 4 和 6 之间的位置，插入这个值，语句执行结束。
这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。

**第二种情况是：目标数据页不在内存中**

**唯一索引**：==需要将数据页读入内存，判断到没有冲突，插入这个值==，语句执行结束；
普通索引：则是将==更新记录在 change buffer==，语句执行就结束了。
主要区别就是唯一索引需要把磁盘中的数据页放入内存。就是这步影响了性能。

将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。 

但是普通索引用change buffer起到加速作用也是有应用场景的。

因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

由此看来就是对于==写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好==。这种业务模型常见的就是==账单类、日志类的系==统。

所以反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。

索引使用选择

从上面的内容来说，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。
如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。

在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。

唯一索引使用的问题，主要是纠结在“业务可能无法确保”的情况。
首先，业务正确性优先==。如果业务不能保证数据的唯一性，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。==本篇文章的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，可以给你多提供一个排查思路。

## 8.内连接、左外连接、右外连接、全外连接的区别

**基本定义：**

　　left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。

　　right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。

　　inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。

　　full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。

```MYSQL
A表　　　　　　　　　　
　　id　  name　　
　　1　　小王
　　2　　小李
　　3　　小刘
　　B表
　　id　　A_id　　job
　　1　　2　　　　老师
　　2　　4　　　　程序员
#内连接
　　select a.name,b.job from A a  inner join B b on a.id=b.A_id
　　只能得到一条记录
　　小李　　老师
#左外连接 左表不加限制
　　select a.name,b.job from A a  left join B b on a.id=b.A_id
　　三条记录
　　小王　　null
　　小李　　老师
　　小刘　　null
#右外连接 右表不加限制
　　select a.name,b.job from A a  right join B b on a.id=b.A_id
　　两条记录
　　小李　　老师
　　null　　程序员
#全连接，在内连接的基础上 左右两表都不加限制
　　select a.name,b.job from A a  full join B b on a.id=b.A_id
　　四条数据
　　小王　　null
　　小李　　老师
　　小刘　　null
　　null　　程序员
```

## 9.java中的各种锁

[【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？](https://www.cnblogs.com/kismetv/p/10787228.html)

[java中的各种锁详细介绍](https://www.cnblogs.com/jyroy/p/11365935.html)



## 10.mysql加锁

### 查看表锁

```mysql
show open tables from db01;
```

![image-20210328204242420](/Users/alan/Library/Application Support/typora-user-images/image-20210328204242420.png)

### 表锁加读锁

```mysql
session1:
lock table mylock read;#session1 对mylock表加读锁
select * from mylock; #可以读
select * from book;#对其他表不可读
update mylock set name = 'a2' where id = 1;#不可写

session2:
select * from mylock; #可以读
select * from book;#可以读其他表
update mylock set name = 'a2' where id = 1;#阻塞住，直到session1对表解锁

unlock tables;
```

### 表锁加写锁

```mysql
session1:
lock table mylock write;#session对mylock表加写锁
select * from mylock;#可以读
select * from book;#其他表不可读
update mylock set name = 'a2' where id = 1;#可以写
#总结 ：session对表mylock独占
session2:
select * from mylock; #阻塞
select * from book;#可以读其他表
update mylock set name = 'a2' where id = 1;#阻塞
unlock tables;
```

==简而言之,就是读锁会阻塞写,但是不会堵塞读。而写锁则会把读和写都堵塞==

可以通过检查 table_ locks waited和 table_ locks_ immediate状态变量来分析系统上的表锁定

![image-20210328165303618](/Users/alan/Library/Application Support/typora-user-images/image-20210328165303618.png)



这里有两个状态变量记录 MYSQLI内部表级锁定的情况,两个变量说明如下
**Table_ locks immediate:**产生表级锁定的次数,表示可以立即获取锁的查询次数,每立即获取锁值加1
**Table_ locks_ waited**:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数,每等待一次锁值加1),此值高则说明存在着较严重的表级锁争用情况

此外, Myisam的读写锁调度是==写优先,==这**也是 myisam不适合做写为主表的引擎**。因为写锁后,其他线程不能做任何操作,大量的更新会使查询很难得到锁,从而造成永远阻塞。



### 行锁

mysql默认事务隔离级别repeated_able read

```mysql
session1
set autocommit = 0;
update test_innodb_lock set b = '4002' where a = 4;
session2
update test_innodb_lock set b = '4003' where a = 4;#阻塞

session1:
commit;

session2:
阻塞恢复
commit;

session1:update test_innodb_lock set b = '4002' where a = 4;
session2:update test_innodb_lock set b = '4002' where a = 5;
#对不同行的修改不会阻塞
```

varchar不加单引号->索引失效->行锁变表锁

==间隙锁：==

【什么是间隙锁】
当我们用范围条件而不是相等条件检素数据,并请求共享或排他锁时, INNODB会给符合条件的已有数据记录的索引项加锁;对于键，值在条件范围内但并不存在的记录,叫做“间隙(GAP)"”,INNODB也会对这个“间隙”加锁,这种锁机制就是所谓的间隙锁(Next-Key锁)。
【危害】
因为 Query执行过程中通过过范围查找的话,他会锁定整个范围内所有的素引键值,即使这个键值并不存在，间隙锁有一个比较致命的弱点,就是当锁定一个范围键值之后,即使某些不存在的键值也会被无辜的锁定,而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。

###  如何手动加行锁

```mysql
#session1
select * from test_innodb_lock where a = 8 for update; 
#session2 
update test_innodb_lock set b = '1999' where a = 8;#阻塞

```

![image-20210328204004424](/Users/alan/Library/Application Support/typora-user-images/image-20210328204004424.png)



11.[java中的各种锁详细介绍](https://www.cnblogs.com/jyroy/p/11365935.html)



# http 

## 1.http1.0 http1.1 http2.0的区别

![img](https://user-gold-cdn.xitu.io/2017/8/3/016c54576b5ac1238fe4df64259e6cb4?imageView2/0/w/1280/h/960/ignore-error/1)

### **HTTP1.0和HTTP1.1的一些区别**

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，==If-Unmodified-Since, If-Match, If-None-Match==等更多可供选择的缓存头来控制缓存策略。
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了==range头域==，它允许只请求资源的某个部分，即==返回码是206==（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1中新增了==24个错误状态响应码==，如==409==（Conflict）表示请求的资源与资源的当前状态发生冲突；==410==（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在==一台物理服务器上可以存在多个虚拟主机==（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应==支持Host头域==，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在==一个TCP连接上可以传送多个HTTP请求和响应==，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： ==keep-alive==，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

### **HTTPS与HTTP的一些区别**

- HTTPS协议需要到==CA申请证书==，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是==明文==，==HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上==，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的==端口==也不一样，前者是==80，后者是443==。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

![img](https://user-gold-cdn.xitu.io/2017/8/3/b6daabee3a064fdc750cf0ff41c69871?imageView2/0/w/1280/h/960/ignore-error/1)

### **HTTP2.0和HTTP1.X相比的新特性**

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，==HTTP2.0使用encoder来减少需要传输的header大小==，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。

### **HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- **HTTP/1.*** 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图：![img](https://user-gold-cdn.xitu.io/2017/8/3/718e6c0340dc43ff55af6f7f08965256?imageView2/0/w/1280/h/960/ignore-error/1)

## 2.长连接、短连接的使用场景

http的长连接和短连接实际上是**TCP的长连接和短连接。**

**区分长/短连接**：整个客户端和服务端的通讯过程是利用一个Socket还是多个Socket进行的。

**长连接**适用于==操作频繁/点对点通讯==等==连接数不太多==的情况，如：一些游戏/即时通讯场景应该使用长连接；如：老师端和学生端的即时通讯教学软件； 最经典的案例是：==数据库使用的连接==（如果使用短连接会造成Socket错误

 **短连接**适用于Web【wapWeb/H5等】的http服务，长连接对于服务端来说会耗费一定资源。对于==电子商务Web的访问量可能是千万级别甚至亿万级别的==。如果使用长连接的方式 ==当一万个用户访问时会占用一万个连接==，假设服务器站点（IIS等）的通信吞吐量只有1千个，那么另外九千人就彻底挂啦，所以并发量大且用户不需要频繁的交互式操作时 用短连接为上策。

**长连接和短连接的优点和缺点**

**长连接**可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。Client与server之间的连接如果一直不关闭的话，会存在一个问题，==随着客户端连接越来越多，server早晚有扛不住的时候，==

**短连接**对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户==请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。==

## 3.如何处理高并发场景下长连接过多带来的问题

## 4.请简单描述http协议的请求报文和响应报文的组成格式

### **HTTP请求报文**

一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

![img](https://images0.cnblogs.com/blog/347600/201302/05005904-154ba75023f849fabd457dd6d194cd98.jpg)

**1.请求头**

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。

HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。

**2.请求头部**

请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

User-Agent：产生请求的浏览器类型。

Accept：客户端可识别的内容类型列表。

Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。

**3.空行**

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

**4.请求数据**

请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。

### **HTTP响应报文**

![img](https://images0.cnblogs.com/blog/347600/201302/05010020-b261c97e0549447c81fcf162d6b0ba72.jpg)

HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。

其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。

常见状态代码、状态描述的说明如下。

- 200 OK：客户端请求成功。
- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
- 403 Forbidden：服务器收到请求，但是拒绝提供服务。
- 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
- 500 Internal Server Error：服务器发生不可预期的错误。
- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。



## 5.http 之session和cookie



- 由于==HTTP协议是无状态的协议==，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

1. **思考一下服务端如何识别特定的客户**？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 ==Cookie 来实现Session跟踪的==，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 ==Cookie 里面记录一个Session ID==，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做**URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。**
2. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。
   所以，总结一下：
   ==Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；==
   ==Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式==

## 6.socket

**3、SOCKET原理**

**3.1套接字（socket）概念**

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：==连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。==

应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

**3.2 建立socket连接**

建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为==ClientSocket== ，另一个运行于服务器端，称为==ServerSocket== 。

套接字之间的连接过程分为三个步骤：==服务器监听，客户端请求，连接确认。==

**服务器监听**：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

**客户端请求**：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

**连接确认**：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

**4、SOCKET连接与TCP/IP连接**

创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

socket则是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：

“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：

“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。” 

实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些。

**5、Socket连接与HTTP连接**

由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

http协议是应用层的协义 

有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 

两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的如HTTP FTP..

## 7.http缓存

[彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)

强制缓存、对比缓存
**对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。**

## 8.http状态码

| 200     | OK                              | 请求成功。一般用于GET与POST请求                              |
| ------- | ------------------------------- | ------------------------------------------------------------ |
| 201     | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202     | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203     | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204     | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205     | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206     | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|         |                                 |                                                              |
| **300** | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301     | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302     | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303     | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304     | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305     | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306     | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307     | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|         |                                 |                                                              |
| **400** | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401     | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402     | Payment Required                | 保留，将来使用                                               |
| 403     | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404     | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405     | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406     | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407     | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408     | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409     | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410     | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411     | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412     | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413     | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414     | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415     | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416     | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417     | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|         |                                 |                                                              |
| **500** | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501     | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502     | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503     | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504     | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505     | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

# 场景题

## [10亿个数中找出最大的10000个数之top K问题](https://blog.csdn.net/zuochao_2013/article/details/79717573)

# Linux

## 1.常用命令

使用ssh远程登录 ssh 用户名@ip 

shutdown shutdown -h now : 表示立即关机 shutdown -h 1 : 表示 1 分钟后关机 shutdown -r now: 立即重启 halt 就是直接使用，效果等价于关机 reboot 就是重启系统。 syn ： 把内存的数据同步到磁盘

useradd +用户名 创建一个用户 并在/home下创建一个家目录

useradd -d 指定一个家目录 +用户名      useradd -d /home/dog  xq

userdel +用户名 删除用户 但保留家目录 

userdel -r +用户名 删除用户和它的家目录

passwd+用户名 修改密码

id+ 用户名 查询用户信息 

su + 用户名 切换到其权限 exit退出

1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。

2)当需要返回到原来用户时，使用 exit 指令

groupadd groupdel 添加/删除组

useradd -g用户组 用户名 创建用户并把用户添加到指定组

usermod-g用户组 用户名 修改用户的组到指定用户组

/etc/paddwd文件用户的配置文件 记录了用户的各种信息

用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell

alan​ :X:500:500:王雷廷:/home/alan:/bin/bash

xh:X:501:501::/home/xh:/bin/bash

xq:X:502:502::/home/xq:/bin/bash



**/etc/shadow 文件**

口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动 时间:失效时间:标志 要切换到root



**/etc/group 文件**

组(group)的配置文件，记录 Linux 包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表

运行级别说明： 0 ：关机 

1 ：单用户【找回丢失密码】

 2：多用户状态没有网络服务

 3：多用户状态有网络服务 

4：系统未使用保留给用户

 5：图形界面

 6：系统重启

 常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件 /etc/inittab 的 id:5:initdefault:这一行中的数字



**获取帮助命令**

man. help +命令

pwd 显示当前路径的绝对路径



**显示文件的命令 ls** 

ls -a 显示隐藏文件

ls -l以列表的形式显示



**cd 切换文件目录的命令**

cd ~ / cd 回到自己的家目录

cd ..回到上一层的目录



**mkdir创建文件夹命令**   -p 一次性创建多级文件夹

rmdir 删除空文件夹.  有文件或文件夹时无法删除

rm -rf 删除非空的目录

touch创建文件

**cp拷贝**  

cp source dest

cp -r 递归拷贝source的所有文件

全部默认覆盖 \cp source dest

rm 删除文件或目录-r 递归删除整个文件夹  -f强制删除不提示



**mv指令移动文件或重命名**

mv oldNameFile newNameFile (功能描述：重命名) 

mv /temp/movefile /targetFolder (功能描述：移动文件)

cat 查看文件 只读  -n显示行号  |more 按页



**more查看文件**

加space 向下翻一页 

enter 向下一行

q 立刻离开more

ctrl+f 向下滚动一屏

Ctrl_b 返回上一屏

= 输出当前行的行号

:f 输出文件名和当前的行号



**less**  less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持 各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示 需要加载内容，对于显示大型文件具有较高的效率。

space/pagedown 向下翻动一页

pageup向上翻动一页

/字串 向下搜寻 n向下 N向上

?字串 向上搜寻 n向下 N向上



\> 输出重定向：会将原来的文件的内容覆盖

\>>追加 不会覆盖原来文件的内容，而是追加到文件的尾部



echo输出内容到控制台

echo $PATH



head +文件  默认显示文件前10行的内容

指定行数 head -n 5 +文件 显示前5行的内容

tail 输出文件的尾部内容 默认后10行	

tail-n 5查看后5行

tail-f实时追踪文档的更新，工作中经常用



ln 软链接、符号链接 类似windows的快捷方式

ln-s原文件目录 软链接名 ln -s /root linkToRoot

rm -rf linkToRoot删除软链接

history查看已经执行过的历史命令



history显示执行过的命令 ＋10  显示最近使用过的10条命令

执行编号为5的命令 !5



1) date （功能描述：显示当前时间）

2) date +%Y （功能描述：显示当前年份）

3) date +%m （功能描述：显示当前月份）

4) date +%d （功能描述：显示当前是哪一天）

5) date "+%Y-%m-%d %H:%M:%S"（功能描述：显示年月日时分秒）

date -s 字符串时间 设置日期

cal显示日历 +年份 显示整年的日历

find查找命令 -name按照指定的文件名进行查找

-user查找属于指定用户的所有文件

-size按照指定大小进行查找

**example:**

find /home/ -name hello.txt (查找home目录下名为hello.txt的文件)

find /opt/ -user xq （查找opt目录下属于用户xq的文件）

find / -size +20M -20M 20M (查找整个linux系统中文件大于、小于、等于20M的文件)

find / -name *.txt (查找linux系统中以.txt为后缀的文件)



locate指令

locaate 指令可以快速定位文件路径。 locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保 证查询结果的准确度，管理员必须定期更新 locate 时刻。


由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 ==updatedb指令创建 locate数据库。==

locate hello.txt



# Docker

Docker概述
Docker安装
Docker命令  :镜像命令 容器命令 操作命令
Dockers镜像

容器数据卷

DockerFile

Docker网络原理

IDEA整合Docker

Docker Compose

Docker Swarm

CI\CD Jenkins 



文档地址：https://docs.docker.com/

比较 Docker和虚拟机技术的不同

传统虚拟机,虚拟出一条硬件,运行一个完整的操作系统,然后在这个系统上安装和运行软件

容器内的应用直接运行在宿主机的内容,容器是没有自己的内核的,也没有虚拟我们的硬件,所以就轻便了 

每个容器可是互相隔离,每个容器内都有一个属于自己的文件系统,互不影响

DevOps(开发、运维）

**应用更快速的交付和部暑** 

传统:一堆帮助文档,安装程序
Docker:打包镜像发步测试,一键运行

**更便捷的升级和扩缩容**

使用了 Docker之后,我们部署应用就和搭积木一样!

**更简单的系统运维**

在容器化之后,我们的开发,测试环境都是高度一致的

**更高效的计算资源利用**

Docker是内核级的虚拟化

可以再一个物理机上可以运行很多的容器实例!服务器的性能可以被压榨到极致

**镜像 image** 模板，通过模板来创建容器服务   tomcat镜像--->run---->tomcat01容器（提供服务器）通过镜像可以创建多个容器，最终的服务和项目是在容器中运行。

**容器 container** 

Docker利用容器技术,独立运行一个或者一个组应用,通过镜像来创建的。 启动,停止,删除,基本命令
目前就可以把这个容器理解为就是一个简易的 llinux系统

**仓库 repository**

分为公有仓库和私有仓库

Docker Hub（默认国外)

阿里云...都有容器的服务器(配置镜像加速)







